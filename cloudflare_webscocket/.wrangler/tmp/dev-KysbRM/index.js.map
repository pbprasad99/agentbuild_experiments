{
  "version": 3,
  "sources": ["../bundle-U7xOVz/checked-fetch.js", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-U7xOVz/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-U7xOVz/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/.wrangler/tmp/dev-KysbRM",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/// <reference types=\"@cloudflare/workers-types\" />\n\n// Environment interface defining the bindings available in the Cloudflare Worker\n// These are configured in wrangler.toml and provide access to Durable Objects, KV storage, and API keys\ninterface Env {\n  WEBSOCKET_HANDLER: DurableObjectNamespace; // Namespace for WebSocket handling Durable Objects\n  CACHE: KVNamespace; // Key-Value store for caching summaries\n  GROQ_API_KEY: string; // API key for Groq AI service\n}\n\n// Durable Object class for managing WebSocket connections\n// Durable Objects provide persistent state and coordination across requests\nexport class WebSocketHandler {\n  state: DurableObjectState; // State of the Durable Object, used for persistence\n  connections: WebSocket[] = []; // Array of active WebSocket connections\n\n  constructor(state: DurableObjectState) {\n    this.state = state;\n  }\n\n  // Handles a new WebSocket session by adding it to connections and setting up event listeners\n  async handleSession(websocket: WebSocket) {\n    this.connections.push(websocket); // Add the WebSocket to the list of active connections\n    websocket.accept(); // Accept the WebSocket connection\n    websocket.addEventListener('message', async (msg) => {\n      // Handle incoming messages if needed (currently no-op)\n    });\n    websocket.addEventListener('close', () => {\n      // Remove the WebSocket from connections when it closes\n      this.connections = this.connections.filter(ws => ws !== websocket);\n    });\n  }\n\n  // Main fetch handler for the Durable Object, handles broadcast requests and WebSocket upgrades\n  async fetch(request: Request) {\n    const url = new URL(request.url);\n    if (url.pathname === '/broadcast') {\n      // Handle broadcast requests by sending the message to all connected clients\n      const body = await request.json();\n      await this.broadcast(JSON.stringify(body));\n      return new Response('Broadcast sent', { status: 200 });\n    }\n    // Otherwise, handle WebSocket upgrade\n    return this.webSocketHandler(request);\n  }\n\n  // Handles WebSocket upgrade requests\n  async webSocketHandler(request: Request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    console.log('DO webSocketHandler called, upgrade:', upgradeHeader);\n    if (upgradeHeader !== 'websocket') {\n      return new Response('Expected websocket', { status: 400 });\n    }\n    // Create a WebSocket pair: client side for the response, server side for handling\n    const [client, server] = Object.values(new WebSocketPair());\n    await this.handleSession(server); // Handle the server-side WebSocket\n    return new Response(null, {\n      status: 101, // Switching Protocols status for WebSocket upgrade\n      webSocket: client, // Return the client-side WebSocket\n    });\n  }\n\n  // Broadcasts a message to all active WebSocket connections\n  async broadcast(message: string) {\n    console.log('Broadcasting message to', this.connections.length, 'connections');\n    this.connections.forEach(ws => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(message); // Send message only if connection is open\n      }\n    });\n  }\n}\n\n// Fetches recent 8-K filings from the SEC EDGAR database\n// 8-K filings are important company announcements required by the SEC\n// This function uses the SEC's RSS feed to get recent filings\nasync function fetchSEC8KFilings(env: Env): Promise<any[]> {\n  // Fetch recent 8-K filings from SEC EDGAR RSS feed\n  // The URL queries for current 8-K filings, limited to 10 most recent\n  const response = await fetch('https://www.sec.gov/cgi-bin/browse-edgar?action=getcurrent&CIK=&type=8-K&company=&dateb=&owner=include&start=0&count=10&output=atom');\n  const text = await response.text();\n  // Note: In a real implementation, you would parse the XML/RSS response to extract filing details\n  // For simplicity in this demo, we're returning mock data instead of parsing XML\n  return [\n    { id: '123', url: 'https://www.sec.gov/example', content: 'Sample 8-K content' }\n  ];\n}\n\n// Summarizes a SEC filing using AI (Groq API)\n// This function handles both production API calls and mock responses for local development\nasync function summarizeWithAI(filing: any, env: Env): Promise<string> {\n  console.log('GROQ_API_KEY present:', !!env.GROQ_API_KEY);\n  // Check if API key is configured; if not or it's the default placeholder, use mock response\n  // This allows the app to run locally without requiring a real API key\n  if (!env.GROQ_API_KEY || env.GROQ_API_KEY === 'your-groq-key') {\n    console.log('Using mock AI response for local testing');\n    return `Mock summary of filing ${filing.id}: This is a test summary for local development. The actual AI API would be called in production with a valid API key.`;\n  }\n\n  // Make API call to Groq for AI-powered summarization\n  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${env.GROQ_API_KEY}`, // Use Bearer token for authentication\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      model: 'llama3-8b-8192', // Specify the AI model to use\n      messages: [{ role: 'user', content: `Summarize this 8-K filing: ${filing.content}` }] // Prompt for summarization\n    })\n  });\n  console.log('API response status:', response.status);\n  console.log('API response ok:', response.ok);\n  if (!response.ok) {\n    const errorText = await response.text();\n    console.error('API error response:', errorText);\n    throw new Error(`API request failed: ${response.status} - ${errorText}`);\n  }\n  try {\n    const data = await response.json();\n    console.log('Parsed data:', data);\n    const typedData = data as any;\n    // Validate the response structure to ensure we have the expected data\n    if (!typedData.choices || !typedData.choices[0] || !typedData.choices[0].message) {\n      throw new Error('Invalid response format from AI API');\n    }\n    return typedData.choices[0].message.content; // Extract the summary from the response\n  } catch (error) {\n    console.error('JSON parsing error:', error);\n    throw error;\n  }\n}\n\n// Default export for the Cloudflare Worker\n// This object contains the handlers for fetch requests and scheduled events\nexport default {\n  // Handle incoming HTTP requests to the worker\n  async fetch(request: Request, env: Env) {\n    const url = new URL(request.url);\n    if (url.pathname === '/test-scheduled') {\n      // Endpoint for testing the scheduled logic manually\n      console.log('Triggering scheduled logic for testing');\n      const filings = await fetchSEC8KFilings(env); // Fetch recent SEC filings\n      for (const filing of filings) {\n        const summary = await summarizeWithAI(filing, env); // Generate AI summary\n        await env.CACHE.put(filing.id, summary); // Store summary in KV cache\n        console.log('Summary stored:', summary);\n        // Broadcast is commented out for now to avoid issues during testing\n        // const id = env.WEBSOCKET_HANDLER.idFromName('singleton');\n        // const stub = env.WEBSOCKET_HANDLER.get(id);\n        // await stub.broadcast(JSON.stringify({ filingId: filing.id, summary }));\n      }\n      return new Response('Scheduled logic executed', { status: 200 });\n    }\n    if (url.pathname === '/simulate' && request.method === 'POST') {\n      // Endpoint for simulating filing data (used by simulate-data.js)\n      console.log('Processing simulated filing data');\n      try {\n        const filing = await request.json() as any; // Get the simulated filing data\n        const summary = await summarizeWithAI(filing, env); // Generate AI summary\n        await env.CACHE.put(filing.id, summary); // Store summary in KV cache\n        console.log('Simulated filing processed and stored:', summary);\n\n        // Broadcast the summary to all connected WebSocket clients\n        const id = env.WEBSOCKET_HANDLER.idFromName('singleton');\n        const stub = env.WEBSOCKET_HANDLER.get(id);\n        await stub.fetch(new Request('http://localhost/broadcast', {\n          method: 'POST',\n          body: JSON.stringify({ filingId: filing.id, summary, company: filing.company, date: filing.date, eventType: filing.eventType }),\n          headers: { 'Content-Type': 'application/json' }\n        }));\n\n        return new Response('Simulated filing processed and broadcast', { status: 200 });\n      } catch (error) {\n        console.error('Error processing simulated filing:', error);\n        return new Response('Error processing simulated filing', { status: 500 });\n      }\n    }\n    const upgradeHeader = request.headers.get('Upgrade');\n    console.log('Request upgrade header:', upgradeHeader);\n    if (upgradeHeader === 'websocket') {\n      // Handle WebSocket upgrade requests by routing to the Durable Object\n      console.log('Handling WebSocket upgrade');\n      const id = env.WEBSOCKET_HANDLER.idFromName('singleton'); // Get or create singleton DO instance\n      const stub = env.WEBSOCKET_HANDLER.get(id); // Get the DO stub for interaction\n      console.log('DO stub obtained');\n      try {\n        return await stub.fetch(request); // Delegate to DO's fetch handler\n      } catch (error) {\n        console.error('Error calling DO fetch:', error);\n        throw error;\n      }\n    }\n    // Default response for non-WebSocket, non-test requests\n    return new Response('WebSocket endpoint', { status: 200 });\n  },\n\n  // Handle scheduled events (runs periodically based on cron configuration in wrangler.toml)\n  // This is where the main business logic runs: fetch filings, summarize, cache, and broadcast\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {\n    const filings = await fetchSEC8KFilings(env); // Get recent SEC filings\n    for (const filing of filings) {\n      const summary = await summarizeWithAI(filing, env); // Generate AI summary\n      await env.CACHE.put(filing.id, summary); // Cache the summary for future retrieval\n      console.log('Summary stored for filing:', filing.id);\n      // Broadcast the new filing summary to all connected WebSocket clients\n      const id = env.WEBSOCKET_HANDLER.idFromName('singleton'); // Get the singleton DO instance\n      const stub = env.WEBSOCKET_HANDLER.get(id); // Get DO stub\n      // Use the DO's broadcast method by making a POST request to its /broadcast endpoint\n      await stub.fetch(new Request('http://localhost/broadcast', {\n        method: 'POST',\n        body: JSON.stringify({ filingId: filing.id, summary }), // Send filing data\n        headers: { 'Content-Type': 'application/json' }\n      }));\n    }\n  }\n};", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/.wrangler/tmp/bundle-U7xOVz/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/.wrangler/tmp/bundle-U7xOVz/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/bpatiban/nbg/ai_experiments/cloudflare_webscocket/.wrangler/tmp/bundle-U7xOVz/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
